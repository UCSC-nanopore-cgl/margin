# Margin #

**Margin** is a pair of tools used for analysis of long-read data using Hidden Markov Models.  It has two submodules: `polish` and `phase`.

**MarginPolish** is a diploid-aware assembly polisher. 
It takes as input a FASTA assembly and an indexed BAM (ONT reads aligned to the assembly), and it produces a haploid or diploid polished FASTA assembly. 
While MarginPolish serves as a standalone assembly polisher, it is also part of an assembly pipeline which includes an ultrafast nanopore assembler [Shasta](https://github.com/chanzuckerberg/shasta) and a multi-task RNN polisher [HELEN](https://github.com/kishwarshafin/helen). 
HELEN operates on images generated by MarginPolish to generate a polished haploid sequence.

**MarginPhase** is a haplotyping utility.
It extracts read substrings around variant sites and uses them to assign reads and variants to diploid haplotypes. 
It takes a BAM, a VCF, and a reference FASTA as input, and it produces a BAM with haplotagged reads and a VCF with phased variants.

## Installation ##

### Dependencies ###

If compiling on Ubuntu, this will install all required packages:
```
apt-get -y install git make gcc g++ autoconf zlib1g-dev libcurl4-openssl-dev libbz2-dev libhdf5-dev
```

Note that libhdf5-dev is required for HELEN image generation with MarginPolish.  MarginPolish and MarginPhase will work without this package, but will not include functionality for HELEN.

MarginPolish is compiled with cmake.  We recommend using the latest cmake version, but 3.7 and higher are supported:
```
wget https://github.com/Kitware/CMake/releases/download/v3.14.4/cmake-3.14.4-Linux-x86_64.sh && sudo mkdir /opt/cmake && sudo sh cmake-3.14.4-Linux-x86_64.sh --prefix=/opt/cmake --skip-license && sudo ln -s /opt/cmake/bin/cmake /usr/local/bin/cmake
cmake --version
```

### Compilation ###

```
# Check out the repository and submodules:
git clone https://github.com/UCSC-nanopore-cgl/margin.git
cd margin
git submodule update --init

# Make build directory:
mkdir build
cd build

# Generate Makefile and run:
cmake ..
make
./margin
 ```

### TODO Docker ###
There is a margin Docker container provided at `docker.io/kishwars/margin_polish`.  To run, the directory with your input files must be mounted onto the `/data` directory in the container.  An example run:

```
docker run -it --rm --user=`id -u`:`id -g` --cpus="16" -v </your/current/directory>:/data kishwars/margin_polish:latest --help
docker run -it --rm --user=`id -u`:`id -g` --cpus="16" -v </your/current/directory>:/data kishwars/margin_polish:latest input.bam input.fasta /opt/MarginPolish/params/<model_name.json> -t 32 -o /data/ -f
```

The entrypoint is to a script which redirects output to a file called `marginPolish.log`.  This also contains output from the `time` program documenting runtime and max memory usage.

The image can be built by navigating to the `docker/` directory and running `make`.  Alternatively, the image can be acquired by running
 
```
docker pull kishwars/margin_polish:latest
```

### Tests ###

Sample data to verify execution of the two tools is provided in the following section, with validation information in the sections after.

Unit tests are contained in the 'allTests' executable, which can be run in your build directory. 
This runs every test and can take up to an hour. 
To test individual components, you can comment out ones you don't want to run in tests/allTests.c.

## Running Margin ##

### Data Formats ###

MarginPolish and MarginPhase require that the input BAM is indexed.  Both utilities can accept read information both in FASTA and FASTQ formats (aligned).  If quality scores are present, the base likelihood is factored into alignment weight estimation.  CRAM format is currently unsupported.

MarginPolish and MarginPhase require an unzipped FASTA reference.  They use an index to access regions of the FASTA, but can generate the index without requiring the user to if the process has write access to the data directory.

MarginPhase supports both gzipped and uncompressed VCFs.  No index is needed.

### Configuration ###

MarginPolish and MarginPhase use a JSON configuration file which contains model and runtime parameterization for:
- Pairwise Alignment
- Graph Alignment
- Run Length Estimation
- Chunking
- Read Filtering
- Depth Downsampling

Both tools have specific parameter files for read data and output goals, all of which extend from a base parameters file containing shared configuration.

For MarginPolish, the run-length estimation correctness is tied to the basecaller version that was used to generate the reads. 
We have trained models for the ONT r9.4 and r10.3 pores with multiple versions of the Guppy basecaller for human and microbial samples, provided in the `ont` folder. 
Additionally we have provided a model trained on PacBio HiFi reads at `pacbio/hifi/allParams.hifi.json`.

For MarginPhase, there are two parameter files for whether your primary objective is to haplotag reads or to phase variants, found in the `misc` folder below.

```
params/
├── base_params.json
├── misc
│   ├── allParams.haplotag_bam.json
│   ├── allParams.no_rle.json
│   └── allParams.phase_vcf.json
├── ont
│   ├── r10.3
│   │   ├── allParams.np.human.r103-g3210.json
│   │   └── allParams.np.microbial.r103g324.json
│   └── r9.4
│       ├── allParams.np.human.r94-g235.json
│       ├── allParams.np.human.r94-g305.json
│       ├── allParams.np.human.r94-g344.json
│       ├── allParams.np.human.r94-g360.json
│       ├── allParams.np.microbial.r94-g305.json
│       └── allParams.np.microbial.r94-g344.json
└── pacbio
    └── hifi
        └── allParams.hifi.json

```

### TODO Test Data ###

## MarginPolish ##

MarginPolish takes reads and alignments from the BAM and generates an initial graph describing matches, inserts, and deletes observed in the alignments.  It aligns each read to this graph and determines the probabilities for multiple likely alignments.  After all reads are aligned, it generates weighted alignment scores for each node in the graph and uses these to determine a most-likely path through the graph.  This path becomes the inital graph for the next iteration of the process.  Iteration continues until the total weighted likelihood of alignments decreases between iteration steps, or until a configured maximum iteration count is reached.

All of these alignments are done in [run-length space](https://en.wikipedia.org/wiki/Run-length_encoding), which simplifies and cleans the alignments.  This reduces effects from errors in homopolymer runs, which are the primary source of error in nanopore reads.  After determining a most-likely run-length-encoded sequence, it expands the run-lengths to generate a final consensus sequence.  This expansion is done using a Bayesian model which predicts the most likely true run-length from all run-length observations in the reads aligned to the node.


### Execution Flow ###

MarginPolish first determines where there are read alignments on the initial assembly segments.  It uses these positions to determine chunk boundaries, including a configurable overlap between chunks. 
Each chunk is polished separately (by a single thread) and the final consensus sequence is stored in memory. 
After all chunks are complete, MarginPolish stitches them together by aligning the overlap between chunks and finding a position to stitch at.  

In diploid mode, MarginPolish identifies candidate sites where variants may be present (alternatively, a VCF can be supplied and the tool will use these sites instead of its own detection strategy). 
It finds read substrings aligned around these sites, uses all unique read substrings as candidate alleles, and aligns all read substrings to all candidate alleles.
These alleles and the read alignments to them are used to construct a graph containing read linkage information between sites. 
The phasing HMM is applied to this graph, and we use this to identify the most likely alleles at each site and the haplotype to which they belong. 
After all chunks are complete, MarginPolish stitches haplotypes together using a set similarity metric between reads assigned to the adjacent chunks' haplotypes, and stitches sequences together using the haploid stitching method.

### Assembly Workflow ###

For a detailed description of the end-to-end assembly workflow, see the documentation provided in the [HELEN](https://github.com/kishwarshafin/helen) repository.


### Running MarginPolish ###

``` 
TODO
```

#### Sample Execution ####

```./marginPolish ../tests/NA12878.np.chr3.5kb.bam ../tests/hg19.chr3.9mb.fa ../params/allParams.np.json -o example_output```


### HELEN Image Generation ###

[HELEN](https://github.com/kishwarshafin/helen) is a multi-task RNN polisher which operates on images produced by MarginPolish.  The images summarize the state of the nodes in the alignment graph before run-length expansion.  They include the weights associated with read observations aligned at each node.

If MarginPolish is configured to generate images (the -f option), it will output a single .h5 file for each thread. 

MarginPolish produces different image types (used during development) which can be configured with the -F flag, but users must use the default type 'splitRleWeight' for the trained models HELEN provides.

To produce HELEN training images, run MarginPolish with the -u flag. 
This takes an argument of an indexed BAM alignment of the truth sequence to the assembly. 
MarginPolish will extract the alignments from this BAM for each analyzed chunk. 
If there is a single alignment at this location with a sequence that approximately matches the chunk's size, it is used to label the images for both nucleotide and run-length. 

### Resource Requirements ###

While comprehensive resource usage profiling has not been done yet, we find that memory usage scales linearly with thread count, read depth, and chunk size. 
For this reason, our default parameters downsample read depth to 64 and restrict chunk size to 100000 bases.

We found that 2GB of memory per thread is sufficient to run haploid MarginPolish on genome-scale assemblies and alignment.

Across 13 whole-genome runs, we averaged roughly 350 CPU hours per gigabase of assembled sequence.



## MarginPhase ##

TODO



© 2019 by Benedict Paten (benedictpaten@gmail.com), Trevor Pesout (tpesout@ucsc.edu)