/*
 * Copyright (C) 2017 by Benedict Paten (benedictpaten@gmail.com)
 *
 * Released under the MIT license, see LICENSE.txt
 */

#include "margin.h"

stGenomeFragment *stGenomeFragment_constructEmpty(stReference *ref, uint64_t refStart, uint64_t length, stSet *reads1, stSet *reads2) {
	stGenomeFragment *gF = st_calloc(1, sizeof(stGenomeFragment));

	// Set coordinates
	gF->reference = ref;
	gF->refStart = refStart;
	gF->length = length;

	// Get the reads which map to each path
	gF->reads1 = reads1;
	gF->reads2 = reads2;

	// Allocate genotype arrays
	gF->genotypeString = st_calloc(gF->length, sizeof(uint64_t));
	gF->genotypeProbs = st_calloc(gF->length, sizeof(float));
	gF->haplotypeProbs1 = st_calloc(gF->length, sizeof(float));
	gF->haplotypeProbs2 = st_calloc(gF->length, sizeof(float));

	// Allocate haplotype arrays
	gF->haplotypeString1 = st_calloc(gF->length, sizeof(uint64_t));
	gF->haplotypeString2 = st_calloc(gF->length, sizeof(uint64_t));
	gF->ancestorString = st_calloc(gF->length, sizeof(uint64_t));

	// Allocate haplotype read coverage arrays
	gF->readsSupportingHaplotype1 = st_calloc(gF->length, sizeof(uint64_t));
	gF->readsSupportingHaplotype2 = st_calloc(gF->length, sizeof(uint64_t));

	return gF;
}

stGenomeFragment *stGenomeFragment_construct(stRPHmm *hmm, stList *path) {
    /*
     * Returns an genome fragment inferred from the hmm and given path through it.
     */

    stGenomeFragment *gF = stGenomeFragment_constructEmpty(hmm->ref,
    		hmm->refStart, hmm->refLength,
			stRPHmm_partitionSequencesByStatePath(hmm, path, 1),
			stRPHmm_partitionSequencesByStatePath(hmm, path, 0));

    // For each cell in the hmm
    stRPColumn *column = hmm->firstColumn;
    for(uint64_t i=0; i<stList_length(path)-1; i++) {
        stRPCell *cell = stList_get(path, i);
        assert(cell != NULL);

        // Calculate the predicted genotype/haplotypes for the given cell
        fillInPredictedGenome(gF, cell->partition, column, (stRPHmmParameters *)hmm->parameters);

        column = column->nColumn->nColumn;
    }

    // Get predictions for the last column
    assert(column != NULL);
    assert(column->nColumn == NULL);
    fillInPredictedGenome(gF, ((stRPCell *)stList_peek(path))->partition, column,
    						(stRPHmmParameters *)hmm->parameters);

    return gF;
}

double getLogProbOfReadGivenHaplotype(const uint64_t *haplotypeString,
                                      int64_t start, int64_t length, stProfileSeq *profileSeq, stReference *ref) {
    /*
     * Returns the log probability of the read given the haplotype.
     */
    double totalProb = 0.0;

    uint64_t firstAllele = ref->sites[profileSeq->refStart].alleleOffset;
    for (int64_t i = 0; i < profileSeq->length; i++) {
        // Get base in the haplotype sequence
        int64_t j = i + profileSeq->refStart - start;
        if (j >= 0 && j < length) {
            uint64_t allele = haplotypeString[j];
            stSite *site = &(ref->sites[i+profileSeq->refStart]);
            totalProb -= profileSeq->profileProbs[site->alleleOffset-firstAllele + allele];
        }
    }
    return totalProb;
}

double getProbabilityOfBeingInPartition(stProfileSeq *pSeq, uint64_t *haplotypeString1, uint64_t *haplotypeString2,
                                                int64_t start, int64_t length, stReference *ref) {
    /*
     * Returns the probability of aread being generated by the first haplotype  of the two haplotype strings.
     */
    double i = getLogProbOfReadGivenHaplotype(haplotypeString1, start, length, pSeq, ref);
    double j = getLogProbOfReadGivenHaplotype(haplotypeString2, start, length, pSeq, ref);
    return i -
           stMath_logAdd(i, j); // TODO: Fix this to be actual probability - currently base of i and j logs is not clear
}

void stGenomeFragment_printPartitionAsCSV(stGenomeFragment *gF, FILE *fh, bool hap1) {
    /*
     * Prints reads in partition as a CSV file, each line being a read name and the probability the read is in the partition.
     */
    fprintf(fh, "READ_NAME,LOG_PROB_OF_BEING_PARTITION\n");
    stSetIterator *it = stSet_getIterator(hap1 ? gF->reads1 : gF->reads2);
    stProfileSeq *pSeq;
    while ((pSeq = stSet_getNext(it)) != NULL) {
        double p = hap1 ? getProbabilityOfBeingInPartition(pSeq, gF->haplotypeString1, gF->haplotypeString2,
                                                           gF->refStart, gF->length, gF->reference) :
                   getProbabilityOfBeingInPartition(pSeq, gF->haplotypeString2, gF->haplotypeString1, gF->refStart,
                                                    gF->length, gF->reference);
        fprintf(fh, "%s,%f\n", pSeq->readId, p);
    }
    stSet_destructIterator(it);
}

stSet *findReadsThatWereMoreProbablyGeneratedByTheOtherHaplotype(uint64_t *haplotypeString1, uint64_t *haplotypeString2,
        int64_t start, int64_t length, stSet *profileSeqs, stReference *ref) {
    /*
     * Returns the subset of profileSeqs that were more probably generated by the second haplotype string
     * than the first.
     */
    stSet *subset = stSet_construct();
    stSetIterator *it = stSet_getIterator(profileSeqs);
    stProfileSeq *pSeq;
    while((pSeq = stSet_getNext(it)) != NULL) {

        // Calculate probability that the read was generated from haplotype1 and haplotype2
        double i = getLogProbOfReadGivenHaplotype(haplotypeString1, start, length, pSeq, ref);
        double j = getLogProbOfReadGivenHaplotype(haplotypeString2, start, length, pSeq, ref);

        if(i < j) {
            // Read is more likely to have been generated by the second haplotype rather than the first
            stSet_insert(subset, pSeq);
        }
    }
    stSet_destructIterator(it);

    return subset;
}

static uint64_t flipReadsBetweenPartitions(uint64_t partition, stRPColumn *column, stSet *flippingReads) {

    for(uint64_t i=0; i<column->depth; i++) {
        stProfileSeq *pSeq = column->seqHeaders[i];

        if(stSet_search(flippingReads, pSeq) != NULL) {
            partition = flipAReadsPartition(partition, i);
        }
    }

    return partition;
}

void stGenomeFragment_refineGenomeFragment(stGenomeFragment *gF,stRPHmm *hmm, stList *path, int64_t maxIterations) {
    /*
     * Refines the genome fragment and read partitions by greedily and iteratively
     * moving reads between the two partitions according to which haplotype they best match.
     */

    // Copy the path as a sequence of unsigned integers, one for each cell on the path
    int64_t pathLength = stList_length(path);
    uint64_t p[pathLength];
    for(int64_t i=0; i<pathLength; i++) {
        p[i] = ((stRPCell *)stList_get(path, i))->partition;
    }

    int64_t iteration = 0;
    while(iteration++ < maxIterations) {
        // Get the subset of reads in each partition that want to switch to the other partition
        stSet *reads1To2 = findReadsThatWereMoreProbablyGeneratedByTheOtherHaplotype(gF->haplotypeString1, gF->haplotypeString2,
                gF->refStart, gF->length, gF->reads1, gF->reference);
        stSet *reads2To1 = findReadsThatWereMoreProbablyGeneratedByTheOtherHaplotype(gF->haplotypeString2, gF->haplotypeString1,
                gF->refStart, gF->length, gF->reads2, gF->reference);

        // If there are no reads wanting to switch then break
        st_logDebug("\tAt iteration %" PRIi64 " of %" PRIi64 " reads, in partition found %" PRIi64 " reads from partition 1 switching to 2 "
                            "and %" PRIi64 " reads from partition 2 switching to 1\n",
                    iteration, stSet_size(gF->reads1) + stSet_size(gF->reads2), stSet_size(reads1To2), stSet_size(reads2To1));
        if(stSet_size(reads1To2) + stSet_size(reads2To1) == 0) {
        	stSet_destruct(reads1To2);
        	stSet_destruct(reads2To1);
            break;
        }

        assert(stSet_size(gF->reads1) + stSet_size(gF->reads2) == stList_length(hmm->profileSeqs));

        // Update the read partitions
        stSet_removeAll(gF->reads1, reads1To2);
        stSet_removeAll(gF->reads2, reads2To1);
        stSet_insertAll(gF->reads1, reads2To1);
        stSet_insertAll(gF->reads2, reads1To2);

        assert(stSet_size(gF->reads1) + stSet_size(gF->reads2) == stList_length(hmm->profileSeqs));

        // Update the path and update the genome fragment
        stRPColumn *column = hmm->firstColumn;
        for(int64_t i=0; i<pathLength; i++) {
            // Update the partition for the column by shifting the reads accordingly
            p[i] = flipReadsBetweenPartitions(p[i], column, reads1To2);
            p[i] = flipReadsBetweenPartitions(p[i], column, reads2To1);

            // Update the genome fragment
            fillInPredictedGenome(gF, p[i], column, (stRPHmmParameters *)hmm->parameters);

            // Get the next column
            if(i+1<pathLength) {
                column = column->nColumn->nColumn;
            }
        }

        // Clean up
        stSet_destruct(reads1To2);
        stSet_destruct(reads2To1);
    }
}

void stGenomeFragment_phaseBamChunkReads(stGenomeFragment *gf, stHash *readsToPSeqs, stList *reads, stSet **readsBelongingToHap1, stSet **readsBelongingToHap2) {
	*readsBelongingToHap1 = stSet_construct();
	*readsBelongingToHap2 = stSet_construct();

	for(int64_t i=0; i<stList_length(reads); i++) {
		BamChunkRead *read = stList_get(reads, i);
		stProfileSeq *pSeq = stHash_search(readsToPSeqs, read);
		if(pSeq != NULL) { // Some reads do not get converted to pSeqs because they are too low quality at every aligned site they
			// overlap

			// Checks
			assert(stSet_search(gf->reads1, pSeq) != NULL || stSet_search(gf->reads2, pSeq) != NULL);
			assert(stSet_search(gf->reads1, pSeq) == NULL || stSet_search(gf->reads2, pSeq) == NULL);

			stSet_insert(stSet_search(gf->reads1, pSeq) != NULL ? *readsBelongingToHap1 : *readsBelongingToHap2,
			        read);
//			        stString_copy(read->readName));
		}
	}
}

void stGenomeFragment_destruct(stGenomeFragment *genomeFragment) {
    // Genotypes
    free(genomeFragment->genotypeString);
    free(genomeFragment->genotypeProbs);
    free(genomeFragment->haplotypeProbs1);
    free(genomeFragment->haplotypeProbs2);

    // Haplotypes
    free(genomeFragment->haplotypeString1);
    free(genomeFragment->haplotypeString2);
    free(genomeFragment->ancestorString);

    // Coverages
    free(genomeFragment->readsSupportingHaplotype1);
    free(genomeFragment->readsSupportingHaplotype2);

    // Reads
    stSet_destruct(genomeFragment->reads1);
    stSet_destruct(genomeFragment->reads2);

    free(genomeFragment);
}

